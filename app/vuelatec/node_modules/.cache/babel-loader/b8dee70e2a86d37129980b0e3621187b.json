{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar crypto_js_1 = require(\"crypto-js\");\n\nvar SimpleCrypto =\n/** @class */\nfunction () {\n  function SimpleCrypto(secret) {\n    if (secret === void 0) {\n      throw new Error('SimpleCrypto object MUST BE initialised with a SECRET KEY.');\n    }\n\n    this._secret = secret;\n    this._keySize = 256;\n    this._iterations = 100;\n    this._defaultEncoder = crypto_js_1.enc.Utf8;\n  }\n\n  SimpleCrypto.generateRandom = function (length, expectsWordArray) {\n    if (length === void 0) {\n      length = 128;\n    }\n\n    if (expectsWordArray === void 0) {\n      expectsWordArray = false;\n    }\n\n    var random = crypto_js_1.lib.WordArray.random(length / 8);\n    return expectsWordArray ? random : random.toString();\n  };\n\n  SimpleCrypto.prototype.encrypt = function (data) {\n    if (data == void 0) {\n      throw new Error('No data was attached to be encrypted. Encryption halted.');\n    }\n\n    var string = typeof data == \"object\" ? JSON.stringify(data) : typeof data == \"string\" || typeof data == \"number\" || typeof data == 'boolean' ? data.toString() : null;\n\n    if (null === string) {\n      throw new Error('Only object, string, number and boolean data types that can be encrypted.');\n    }\n\n    var salt = SimpleCrypto.generateRandom(128, true);\n    var key = crypto_js_1.PBKDF2(this._secret, salt, {\n      keySize: this._keySize / 32,\n      iterations: this._iterations\n    });\n    var initialVector = SimpleCrypto.generateRandom(128, true);\n    var encrypted = crypto_js_1.AES.encrypt(string, key, {\n      iv: initialVector,\n      padding: crypto_js_1.pad.Pkcs7,\n      mode: crypto_js_1.mode.CBC\n    });\n    return salt.toString() + initialVector.toString() + encrypted.toString();\n  };\n\n  SimpleCrypto.prototype.decrypt = function (ciphered, expectsObject, encoder) {\n    if (expectsObject === void 0) {\n      expectsObject = false;\n    }\n\n    if (encoder === void 0) {\n      encoder = this._defaultEncoder;\n    }\n\n    if (ciphered == void 0) {\n      throw new Error('No encrypted string was attached to be decrypted. Decryption halted.');\n    }\n\n    var salt = crypto_js_1.enc.Hex.parse(ciphered.substr(0, 32));\n    var initialVector = crypto_js_1.enc.Hex.parse(ciphered.substr(32, 32));\n    var encrypted = ciphered.substring(64);\n    var key = crypto_js_1.PBKDF2(this._secret, salt, {\n      keySize: this._keySize / 32,\n      iterations: this._iterations\n    });\n    var decrypted = crypto_js_1.AES.decrypt(encrypted, key, {\n      iv: initialVector,\n      padding: crypto_js_1.pad.Pkcs7,\n      mode: crypto_js_1.mode.CBC\n    });\n    return expectsObject ? JSON.parse(decrypted.toString(encoder)) : decrypted.toString(encoder);\n  };\n\n  SimpleCrypto.prototype.encryptObject = function (object) {\n    return this.encrypt(object);\n  };\n\n  SimpleCrypto.prototype.decryptObject = function (string) {\n    var decrypted = this.decrypt(string, true);\n    return typeof decrypted == 'object' ? decrypted : JSON.parse(decrypted);\n  };\n\n  SimpleCrypto.prototype.setSecret = function (secret) {\n    this._secret = secret;\n  };\n\n  return SimpleCrypto;\n}();\n\nexports.SimpleCrypto = SimpleCrypto;\nexports.default = SimpleCrypto;","map":null,"metadata":{},"sourceType":"script"}